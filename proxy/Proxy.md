### 프록시, 프록시 패턴, 데코레이터 패턴 소개

`클라이언트-서버 구조`에서 `클라이언트`는 서버에 필요한 것을 요청, `서버`는 클라이언트의 요청을 처리

`프록시`는 클라이언트-서버 사이에 위치해 클라이언트의 요청을 서버에게 대신 요청하거나, 다른 역할을 수행할 수 있다

- 접근제어, 캐싱
- 추가 기능
- 프록시 체인

### 대체 가능
객체에서 프록시가 되려면, 클라이언트는 서버에게 요청을 한 것인지, 프록시에게 요청을 한 것인지 조차 몰라야 한다.

다시 말해 서버와 프록시는 `같은 인터페이스`를 사용해야 한다. 그리고 클라이언트가 사용하느
서버 객체를 프록시 객체로 변경해도 클라이언트 코드를 변경하지 않고 동작할 수 있어야 한다.

### 런타임 객체 의존 관계
런타임에 클라이언트 객체에 DI를 사용해서 Client -> Server에서 Client -> Proxy로
객체 의존 관계로 변경해도 클라이언트 코드를 전혀 변경하지 않아도 된다. 클라이언트 입장에서는
변경 사실 조차 모른다.

DI를 사용해 클라이언트 코드의 변경 없이 유연하게 프록시를 주입할 수 있다.

### 데코레이터 패턴과 프록시 패턴

둘 다 `프록시`를 사용하는 방법이지만 GOF 디자인 패턴에서는 이 둘을 의도에 따라서
프록시 패턴과 데코레이터 패턴으로 구분한다

- `프록시 패턴`: `접근 제어`가 목적
- `데코레이터 패턴`: `새로운 기능 추가`가 목적

꾸며주는 역할을 수행하는 데코레이터는 홀로 존재할 수 없다.
항상 꾸며줄 대상이 있어야 한다.

따라서 내부에 호출 대상인 component를 갖고 있어야 한다.
그리고 component를 항상 호출해야 하는데, 이 부분이 중복이다.

이런 중복을 제거하기 위해 component를 속성으로 갖고 있는 Decorator라는 
추상 클래스를 만들 수도 있다.

그렇게 하면 클래스 다이어그램에서 어떤 것이 실제 컴포넌트인지, 데코레이터인지 
명확하게 구분할 수 있다.

