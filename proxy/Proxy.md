### 프록시, 프록시 패턴, 데코레이터 패턴 소개

`클라이언트-서버 구조`에서 `클라이언트`는 서버에 필요한 것을 요청, `서버`는 클라이언트의 요청을 처리

`프록시`는 클라이언트-서버 사이에 위치해 클라이언트의 요청을 서버에게 대신 요청하거나, 다른 역할을 수행할 수 있다

- 접근제어, 캐싱
- 추가 기능
- 프록시 체인

### 대체 가능
객체에서 프록시가 되려면, 클라이언트는 서버에게 요청을 한 것인지, 프록시에게 요청을 한 것인지 조차 몰라야 한다.

다시 말해 서버와 프록시는 `같은 인터페이스`를 사용해야 한다. 그리고 클라이언트가 사용하느
서버 객체를 프록시 객체로 변경해도 클라이언트 코드를 변경하지 않고 동작할 수 있어야 한다.

### 런타임 객체 의존 관계
런타임에 클라이언트 객체에 DI를 사용해서 Client -> Server에서 Client -> Proxy로
객체 의존 관계로 변경해도 클라이언트 코드를 전혀 변경하지 않아도 된다. 클라이언트 입장에서는
변경 사실 조차 모른다.

DI를 사용해 클라이언트 코드의 변경 없이 유연하게 프록시를 주입할 수 있다.

### 데코레이터 패턴과 프록시 패턴

둘 다 `프록시`를 사용하는 방법이지만 GOF 디자인 패턴에서는 이 둘을 의도에 따라서
프록시 패턴과 데코레이터 패턴으로 구분한다

- `프록시 패턴`: `접근 제어`가 목적
- `데코레이터 패턴`: `새로운 기능 추가`가 목적

꾸며주는 역할을 수행하는 데코레이터는 홀로 존재할 수 없다.
항상 꾸며줄 대상이 있어야 한다.

따라서 내부에 호출 대상인 component를 갖고 있어야 한다.
그리고 component를 항상 호출해야 하는데, 이 부분이 중복이다.

이런 중복을 제거하기 위해 component를 속성으로 갖고 있는 Decorator라는 
추상 클래스를 만들 수도 있다.

그렇게 하면 클래스 다이어그램에서 어떤 것이 실제 컴포넌트인지, 데코레이터인지 
명확하게 구분할 수 있다.

### 인터페이스 기반 프록시 vs 클래스 기반 프록시

- `클래스 기반 프록시`는 해당 클래스에만 적용할 수 있다
- `인터페이스 기반 프록시`는 인터페이스만 같으면 모든 곳에 적용할 수 있다
- 클래스 기반 프록시는 상속을 사용하기 때문에 몇 가지 제약이 있다
  - 부모 클래스의 생성자를 호출해야 한다
  - 클래스에 final 키워드가 붙으면 상속이 불가능하다
  - 메서드에 final 키워드가 붙으면 해당 메서드를 오버라이딩할 수 없다

인터페이스 기반 프록시가 무조건 더 좋아보이기도 하고, 맞기도 하다.

인터페이스 기반 프록시는 인터페이스가 필요하다는 것 그 자체가 단점이다.

이론적으로는 모든 객체에 인터페이스를 도입해서 역할과 구현을 나누는 것이 좋다.
이렇게 하면 역할과 구현을 나누어서 구현체를 매우 편리하게 변경할 수 있다.

하지만 실제로는 구현을 거의 변경할 일이 없는 클래스도 많다.
구현을 변경할 가능성이 거의 없는 코드에 무작정 인터페이스를 사용하는 것은 번거롭고 그다지 실용적이지 않다.

### 너무 많은 프록시 클래스

프록시를 적용해서 기존 코드를 변경하지 않고 부가 기능을 적용할 수 있었다.

하지만 프록시도 한계점이 있는데, 프록시 클래스를 너무 많이 만들어야 한다는 점이다.

프록시 클래스가 하는 일은 LogTrace를 사용하는 것이고, 그 로직은 모두 똑같고 대상 클래스만 다르다.

적용해야 하는 대상 클래스가 100개라면 프록시 클래스도 100개를 만들어야 한다.

프록시 클래스를 하나만 만들어서 모든 곳에 적용하는 방법은 없을까?

동적 프록시 기술이 이에 대한 해답이다.