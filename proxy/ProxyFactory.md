### 동적 프록시의 한계와 프록시 팩토리
- 인터페이스가 있는 경우에는 JDK 동적 프록시를 적용하고, 그렇지 않은 경우에는 CGLIB을 적용하려면 어떻게 해야 할까?

스프링은 유사한 구체적인 기술이 있을 때 이를 통합해서 일관성 있게 접근할 수 있고, 
더욱 편리하게 사용할 수 있는 추상화된 기술을 제공한다. `프록시 팩토리` 하나로 
인터페이스가 있을 때는 JDK 동적 프록시를 사용하고, 구체 클래스만 있다면 CGLIB을 사용할 수 있다.
설정을 통해 원하는 것만 사용할 수도 있다.

- 두 기술을 함께 사용할 때 부가 기능을 제공하기 위해 JDK 동적 프록시가 제공하는 InvocationHandler와 
CGLIB가 제공하는 MethodInterceptor를 각각 중복으로 만들어서 관리해야 하는가?

스프링에는 이를 해결하기 위해 부가 기능을 적용할 때 `Advice`라는 개념을 도입했다.
개발자는 InvocationHandler나 MethodInterceptor를 신경쓰지 않고, `Advice`만 만들면 된다.
결과적으로 InvocationHandler나 MethodInterceptor는 Advice를 호출하게 된다.

- 특정 조건이 맞을 때에만 프록시 로직을 적용하는 기능도 공통으로 제공하려면?

스프링은 `Pointcut`이라는 개념을 도입해서 이 문제를 일관성 있게 해결한다.

### 포인트컷, 어드바이스, 어드바이저 소개

- 포인트컷(`Pointcut`)

어디에 부가 기능을 적용할지, 어디에 부가 기능을 적용하지 않을지 판단하는 필터링 로직이다.
주로 클래스와 메서드 이름으로 필터링한다. 이름 그대로 어떤 포인트(point)에 기능을 적용할지 하지 않을지
잘라서(cut) 구분하는 것이다.

- 어드바이스(`Advice`)

이전에 본 것처럼 프록시가 호출하는 부가 기능이다. 프록시 로직이라 생각하면 된다.

- 어드바이저(`Advisor`)

하나의 포인트컷과 하나의 어드바이스를 갖는 것이다.

정리하자면, `포인트컷`은 `어디에 적용할지` 선택하고, `어드바이스`는 `어떤 로직을 적용할지` 선택하는 것이다.

*역할과 책임*
- 포인트컷은 대상 여부를 확인하는 필터 역할을 담당한다
- 어드바이스는 부가 기능 로직만 담당한다
- 둘을 합치면 어드바이저가 된다. 어드바이저는 하나의 포인트컷 + 하나의 어드바이스로 구성된다

### 한계점

프록시 팩토리와 어드바이저 같은 개념 덕분에 대부분의 문제는 해결되었다.
프록시도 깔끔하게 적용하고 포인트컷으로 어디에 부가 기능을 적용할지도 명확하게 정의할 수 있다.
원본 코드를 전혀 손대지 않고 프록시를 통해 부가 기능도 적용할 수 있다.

하지만 아직 해결되지 않은 문제가 있다.

**문제1 - 너무 많은 설정**

ProxyFactoryConfigV1, ProxyFactoryConfigV2와 같은 설정 파일이 지나치게 많다는 점이다.

예를 들어 애플리케이션에 스프링 빈이 100개가 있다면 여기에 프록시를 통해 부가 기능을 적용하려면
100개의 동적 프록시 생성 코드를 만들어야 한다.

최근에는 스프링 빈을 등록하기 귀찮아서 컴포넌트 스캔까지 사용하는데, 이렇게 직접 등록하는 것도
모자라서 프록시를 적용하는 코드까지 빈 생성 코드에 넣어야 한다.

**문제2 - 컴포넌트 스캔**
애플리케이션 V3처럼 컴포넌트 스캔을 사용하는 경우 지금까지의 방법으로는 프록시 적용이 불가능하다.

실제 객체를 컴포넌트 스캔으로 스프링 컨테이너에 스프링 빈으로 등록을 다 해버린 상태이기 때문이다.

지금까지 학습한 프록시를 적용하려면, 실제 객체를 스프링 컨테이너에 빈으로 등록하는 것이 아니라

ProxyFactoryConfigV1에서 한 것처럼, 부가 기능이 있는 프록시를 실제 객체 대신 스프링 컨테이너에
빈으로 등록해야 한다.

**=> 두 가지 문제를 한 번에 해결하는 방법이 빈 후처리기이다.**