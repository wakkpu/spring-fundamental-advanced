### 변하는 것과 변하지 않는 것을 분리

좋은 설계는 변하는 것과 변하지 않는 것을 분리하는 것이다.

핵심 기능 부분은 변하고, 로깅과 같은 부분은 변하지 않는 부분이다.

따라서, 이 둘을 분리해서 모듈화해야 한다.

템플릿 메서드 패턴은 이런 문제를 해결하는 디자인 패턴이다.

잘 변하지 않는 코드와 잘 변하는 코드를 분리함으로써 코드의 중복을 제거하고,

변경 사항이 생겼을 때 해당 오버라이드된 메서드만 수정함으로써 단일 책임 원칙을 준수할 수 있다.

하지만 템플릿 메서드 패턴에도 단점이 있다.

자주 변하는 메서드를 분리하긴 했지만, 종류만큼의 자식 클래스를 새로 정의해야 하는 단점이 존재한다.

익명 내부 클래스를 사용하면 이런 단점을 보완할 수 있다.

`작업에서 알고리즘의 골격을 정의하고 일부 단계를 하위 클래스로 연기합니다. 템플릿 메서드를 사용하면 하위 클래스가 알고리즘의 구조를 변경하지 않고도 알고리즘의 특정 단계를 재정의할 수 있습니다`

-> 부모 클래스에 알고리즘의 골격인 템플릿을 정의하고, 로직은 자식 클래스에 정의하는 것이다.

이렇게 하면 자식 클래스가 알고리즘의 전체 구조를 변경하지 않고 특정 부분만 재정의할 수 있다.

상속과 오버라이딩을 통한 다형성으로 문제를 해결하는 것이다.

하지만 상속을 사용하므로 상속에서 오는 단점들을 그대로 안고 간다.

특히 자식 클래스가 부모 클래스와 컴파일 시점에 강하게 결합되는 문제가 있다.

자식 클래스는 부모 클래스의 기능을 전혀 사용하지 않음에도 불구하고 부모 클래스를 상속받음으로써 부모 클래스를 알아야 하는 상황이다.

추가적으로 상속 구조를 사용하기 때문에 별도의 클래스나 익명 내부 클래스를 만들어야 하는 부분도 복잡하다.

-> 템플릿 메서드 패턴과 비슷한 역할을 하면서 상속의 단점을 제거할 수 있는 디자인 패턴이 바로 `상속 패턴`이다